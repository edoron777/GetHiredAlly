═══════════════════════════════════════════════════════════════════════════════
PROJECT: CV Issue Catalog Backend - PROMPT 3 OF 10
═══════════════════════════════════════════════════════════════════════════════

CONTEXT:
Continuing from Prompt C2. Repository created.

───────────────────────────────────────────────────────────────────────────────

TASK: Create Catalog Cache

Create a new file: backend/common/catalog/cache.py

This is the in-memory cache that loads data once and serves from memory.
Critical for performance - no database queries at runtime.

───────────────────────────────────────────────────────────────────────────────

FILE TO CREATE: backend/common/catalog/cache.py

```python
"""
CV Issue Catalog - Cache Layer

In-memory cache for CV Issue Catalog.
Loads entire catalog on startup and serves from memory.
"""

import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from .models import (
    Category, 
    Subcategory, 
    IssueType, 
    CatalogSummary
)
from .repository import CatalogRepository

logger = logging.getLogger(__name__)


class CatalogCache:
    """
    In-memory cache for CV Issue Catalog.
    
    Singleton pattern - one instance shared across the application.
    Loads entire catalog on startup and serves all queries from memory.
    """
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        
        # Data storage
        self._categories: List[Category] = []
        self._subcategories: List[Subcategory] = []
        self._all_issues: List[IssueType] = []
        self._legacy_mapping: Dict[str, str] = {}
        
        # Indexes for fast lookup
        self._issues_by_code: Dict[str, IssueType] = {}
        self._issues_by_category: Dict[str, List[IssueType]] = {}
        self._issues_by_severity: Dict[str, List[IssueType]] = {}
        self._issues_by_subcategory: Dict[str, List[IssueType]] = {}
        
        # Cache state
        self._loaded_at: Optional[datetime] = None
        self._is_loaded: bool = False
        self._ttl: timedelta = timedelta(hours=1)
        
        self._initialized = True
    
    @property
    def is_loaded(self) -> bool:
        """Check if cache has been loaded"""
        return self._is_loaded
    
    @property
    def is_stale(self) -> bool:
        """Check if cache should be refreshed based on TTL"""
        if not self._loaded_at:
            return True
        return datetime.now() - self._loaded_at > self._ttl
    
    @property
    def loaded_at(self) -> Optional[datetime]:
        """When the cache was last loaded"""
        return self._loaded_at
    
    def load(self, repository: CatalogRepository, force: bool = False) -> None:
        """
        Load entire catalog into memory.
        
        Args:
            repository: Database repository to fetch from
            force: Force reload even if already loaded
        """
        if self._is_loaded and not force and not self.is_stale:
            logger.debug("Cache already loaded and fresh, skipping")
            return
        
        logger.info("Loading CV Issue Catalog into cache...")
        start_time = datetime.now()
        
        try:
            # Fetch all data from database
            self._categories = repository.fetch_all_categories()
            self._subcategories = repository.fetch_all_subcategories()
            self._all_issues = repository.fetch_all_issues()
            self._legacy_mapping = repository.fetch_legacy_mapping()
            
            # Build indexes for fast lookup
            self._build_indexes()
            
            # Update cache state
            self._loaded_at = datetime.now()
            self._is_loaded = True
            
            load_time = (datetime.now() - start_time).total_seconds() * 1000
            logger.info(
                f"Cache loaded: {len(self._all_issues)} issues, "
                f"{len(self._categories)} categories, "
                f"{len(self._legacy_mapping)} legacy mappings. "
                f"Time: {load_time:.2f}ms"
            )
            
        except Exception as e:
            logger.error(f"Failed to load catalog cache: {e}")
            raise
    
    def _build_indexes(self) -> None:
        """Build lookup indexes for fast access"""
        self._issues_by_code = {}
        self._issues_by_category = {}
        self._issues_by_severity = {}
        self._issues_by_subcategory = {}
        
        for issue in self._all_issues:
            # Index by code
            self._issues_by_code[issue.issue_code] = issue
            
            # Index by category
            cat_code = issue.category_code
            if cat_code:
                if cat_code not in self._issues_by_category:
                    self._issues_by_category[cat_code] = []
                self._issues_by_category[cat_code].append(issue)
            
            # Index by severity
            sev = issue.severity
            if sev not in self._issues_by_severity:
                self._issues_by_severity[sev] = []
            self._issues_by_severity[sev].append(issue)
            
            # Index by subcategory
            subcat_code = issue.subcategory_code
            if subcat_code:
                if subcat_code not in self._issues_by_subcategory:
                    self._issues_by_subcategory[subcat_code] = []
                self._issues_by_subcategory[subcat_code].append(issue)
    
    def invalidate(self) -> None:
        """Invalidate cache, forcing reload on next access"""
        self._is_loaded = False
        self._loaded_at = None
        logger.info("Catalog cache invalidated")
    
    def _ensure_loaded(self) -> None:
        """Raise error if cache not loaded"""
        if not self._is_loaded:
            raise RuntimeError(
                "Catalog cache not loaded. Initialize the service first."
            )
    
    # ─────────────────────────────────────────────────────────────────
    # Query Methods (all read from memory - instant!)
    # ─────────────────────────────────────────────────────────────────
    
    def get_all_issues(self) -> List[IssueType]:
        """Get all issue types"""
        self._ensure_loaded()
        return self._all_issues.copy()
    
    def get_issue_by_code(self, code: str) -> Optional[IssueType]:
        """Get issue by code, returns None if not found"""
        self._ensure_loaded()
        return self._issues_by_code.get(code)
    
    def get_issues_by_category(self, category_code: str) -> List[IssueType]:
        """Get all issues in a category"""
        self._ensure_loaded()
        return self._issues_by_category.get(category_code, []).copy()
    
    def get_issues_by_severity(self, severity: str) -> List[IssueType]:
        """Get all issues with a severity level"""
        self._ensure_loaded()
        return self._issues_by_severity.get(severity, []).copy()
    
    def get_issues_by_subcategory(self, subcategory_code: str) -> List[IssueType]:
        """Get all issues in a subcategory"""
        self._ensure_loaded()
        return self._issues_by_subcategory.get(subcategory_code, []).copy()
    
    def get_categories(self) -> List[Category]:
        """Get all categories"""
        self._ensure_loaded()
        return self._categories.copy()
    
    def get_subcategories(self) -> List[Subcategory]:
        """Get all subcategories"""
        self._ensure_loaded()
        return self._subcategories.copy()
    
    def normalize_legacy_code(self, old_code: str) -> str:
        """
        Convert legacy issue code to new code.
        Returns original code if no mapping exists.
        """
        self._ensure_loaded()
        return self._legacy_mapping.get(old_code, old_code)
    
    def get_legacy_mapping(self) -> Dict[str, str]:
        """Get full legacy mapping dictionary"""
        self._ensure_loaded()
        return self._legacy_mapping.copy()
    
    def get_summary(self) -> CatalogSummary:
        """Get catalog statistics"""
        self._ensure_loaded()
        
        auto_fixable = sum(1 for i in self._all_issues if i.can_auto_fix)
        
        return CatalogSummary(
            total_categories=len(self._categories),
            total_subcategories=len(self._subcategories),
            total_issue_types=len(self._all_issues),
            issues_by_severity={
                sev: len(issues) 
                for sev, issues in self._issues_by_severity.items()
            },
            issues_by_category={
                cat: len(issues) 
                for cat, issues in self._issues_by_category.items()
            },
            auto_fixable_count=auto_fixable,
            last_loaded=self._loaded_at
        )
```

───────────────────────────────────────────────────────────────────────────────

VERIFICATION:
- [ ] File created: backend/common/catalog/cache.py
- [ ] No syntax errors
- [ ] Singleton pattern implemented
- [ ] All query methods defined

═══════════════════════════════════════════════════════════════════════════════