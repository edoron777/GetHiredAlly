═══════════════════════════════════════════════════════════════════
FIX: Job Detection - Handle Blank Lines
═══════════════════════════════════════════════════════════════════

FILE: backend/common/detection/section_extractor.py

FIND this function (around line 215-245):

def _detect_job_entry_start(line: str, next_lines: List[str]) -> bool:

REPLACE THE ENTIRE FUNCTION with:

───────────────────────────────────────────────────────────────────

def _detect_job_entry_start(line: str, next_lines: List[str]) -> bool:
    """
    Detect if this line starts a job entry.
    
    Requirements:
    - Must have date pattern nearby (current line or next 5 NON-BLANK lines)
    - Must have company name OR job title
    """
    line_stripped = line.strip()
    if not line_stripped:
        return False
    
    # Check current line
    has_company = any(company.lower() in line_stripped.lower() for company in KNOWN_COMPANIES)
    has_title = any(re.search(p, line_stripped, re.IGNORECASE) for p in JOB_TITLE_PATTERNS)
    has_date = any(re.search(p, line_stripped, re.IGNORECASE) for p in DATE_PATTERNS)
    
    # Direct match: date + (company or title) on same line
    if has_date and (has_company or has_title):
        return True
    
    # Skip very long lines (likely paragraph text, not job header)
    if len(line_stripped) > 100:
        return False
    
    # Check if line looks like job start (company or title) with date nearby
    if (has_company or has_title) and line_stripped and line_stripped[0].isupper():
        # FIXED: Filter out blank lines and check more lines
        non_blank_lines = [l for l in next_lines if l.strip()][:5]  # Up to 5 non-blank lines
        upcoming_text = ' '.join(non_blank_lines)
        
        has_date_nearby = any(re.search(p, upcoming_text, re.IGNORECASE) for p in DATE_PATTERNS)
        
        if has_date_nearby:
            logger.debug(f"[JOB_DETECT] Found job entry: '{line_stripped[:50]}...' with date in next lines")
            return True
    
    # NEW: Check for bold company name pattern like "**Citi**"
    bold_company_pattern = r'^\*\*([A-Z][a-zA-Z\s&,\.]+)\*\*\s*$'
    match = re.match(bold_company_pattern, line_stripped)
    if match:
        company_name = match.group(1).strip()
        # Check if it's a known company OR followed by job indicators
        if any(company.lower() == company_name.lower() for company in KNOWN_COMPANIES):
            non_blank_lines = [l for l in next_lines if l.strip()][:5]
            upcoming_text = ' '.join(non_blank_lines)
            has_date_nearby = any(re.search(p, upcoming_text, re.IGNORECASE) for p in DATE_PATTERNS)
            if has_date_nearby:
                logger.debug(f"[JOB_DETECT] Found bold company job entry: '{company_name}'")
                return True
    
    return False

───────────────────────────────────────────────────────────────────

CHANGES MADE:
1. Filter out blank lines: non_blank_lines = [l for l in next_lines if l.strip()]
2. Look at 5 non-blank lines instead of 3: [:5]
3. Added bold company pattern detection: **Citi**
4. Added debug logging

───────────────────────────────────────────────────────────────────

ALSO: Update the scanning in extract_sections to pass more lines

FIND (around line 408-415):
                remaining = [l.strip() for l in lines[scan_line+1:scan_line+6]] if scan_line+1 < len(lines) else []

REPLACE WITH:
                remaining = [l.strip() for l in lines[scan_line+1:scan_line+10]] if scan_line+1 < len(lines) else []

This gives _detect_job_entry_start more lines to work with.

───────────────────────────────────────────────────────────────────

VERIFICATION:
After fix, rescan CV and check console for:
[JOB_DETECT] Found job entry: '**Citi**' with date in next lines

Type "JOB DETECTION FIX COMPLETE" when done.