â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’» REPLIT-3#10: Create Abbreviation Consistency Detector
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ ANTI-IMPROVISATION DIRECTIVE:
- Execute ONLY the instructions below
- Create ONLY the specified file
- Do NOT add extra features
- If unclear â†’ STOP and ask

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PROBLEM:

No detector exists for inconsistent abbreviation usage.
Example: CV uses both "AI" (43 times) and "Artificial Intelligence" (1 time)

EXPECTED BEHAVIOR:
- Detect when BOTH abbreviated AND full form are used
- Recommend fixing the MINORITY form (not all occurrences)
- Enable auto-fix for the minority occurrences only
- Example: If "AI" appears 43x and "Artificial Intelligence" 1x
  â†’ Flag only the 1 occurrence of "Artificial Intelligence"
  â†’ Suggest replacing with "AI" (the majority form)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE TO CREATE:

backend/common/detection/abbreviation_detector.py

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

COMPLETE CODE:

"""
Abbreviation Consistency Detector

Detects inconsistent use of abbreviations vs full forms.
Rule: Fix the MINORITY form, not all occurrences.

DETERMINISTIC: Same text â†’ Same issues (always)
"""

import re
from typing import List, Dict, Tuple

# Common abbreviation pairs in tech CVs
ABBREVIATION_PAIRS = [
    ('AI', 'Artificial Intelligence'),
    ('ML', 'Machine Learning'),
    ('NLP', 'Natural Language Processing'),
    ('API', 'Application Programming Interface'),
    ('AWS', 'Amazon Web Services'),
    ('GCP', 'Google Cloud Platform'),
    ('UI', 'User Interface'),
    ('UX', 'User Experience'),
    ('CI/CD', 'Continuous Integration/Continuous Deployment'),
    ('CI', 'Continuous Integration'),
    ('CD', 'Continuous Deployment'),
    ('SQL', 'Structured Query Language'),
    ('SaaS', 'Software as a Service'),
    ('PaaS', 'Platform as a Service'),
    ('IaaS', 'Infrastructure as a Service'),
    ('KPI', 'Key Performance Indicator'),
    ('ROI', 'Return on Investment'),
    ('PM', 'Project Manager'),
    ('PM', 'Product Manager'),
    ('QA', 'Quality Assurance'),
    ('DevOps', 'Development Operations'),
    ('IoT', 'Internet of Things'),
    ('VR', 'Virtual Reality'),
    ('AR', 'Augmented Reality'),
]


def count_occurrences(text: str, term: str, case_sensitive: bool = False) -> int:
    """Count occurrences of a term in text."""
    if case_sensitive:
        pattern = r'\b' + re.escape(term) + r'\b'
    else:
        pattern = r'\b' + re.escape(term) + r'\b'
        return len(re.findall(pattern, text, re.IGNORECASE))
    return len(re.findall(pattern, text))


def find_all_positions(text: str, term: str) -> List[Tuple[int, int, str]]:
    """Find all positions of a term in text. Returns (start, end, matched_text)."""
    pattern = r'\b' + re.escape(term) + r'\b'
    matches = []
    for match in re.finditer(pattern, text, re.IGNORECASE):
        matches.append((match.start(), match.end(), match.group()))
    return matches


def detect_abbreviation_issues(text: str) -> List[Dict]:
    """
    Detect inconsistent abbreviation usage.
    
    RULE: If both forms are used, flag the MINORITY form for fixing.
    This allows auto-fix to replace only the minority occurrences.
    """
    issues = []
    
    for abbrev, full_form in ABBREVIATION_PAIRS:
        abbrev_count = count_occurrences(text, abbrev)
        full_count = count_occurrences(text, full_form)
        
        # Only flag if BOTH forms are used
        if abbrev_count > 0 and full_count > 0:
            # Determine which is minority
            if abbrev_count > full_count:
                # Full form is minority â†’ fix full form occurrences
                minority_term = full_form
                majority_term = abbrev
                minority_count = full_count
                majority_count = abbrev_count
            elif full_count > abbrev_count:
                # Abbreviation is minority â†’ fix abbreviation occurrences
                minority_term = abbrev
                majority_term = full_form
                minority_count = abbrev_count
                majority_count = full_count
            else:
                # Equal counts - prefer abbreviation (shorter)
                minority_term = full_form
                majority_term = abbrev
                minority_count = full_count
                majority_count = abbrev_count
            
            # Find positions of minority term for match_text
            positions = find_all_positions(text, minority_term)
            
            # Create ONE issue per inconsistency (not per occurrence)
            # The issue lists how many to fix
            issues.append({
                'issue_type': 'FORMAT_INCONSISTENT_ABBREVIATION',
                'match_text': minority_term,
                'suggestion': f"Use '{majority_term}' consistently. Replace {minority_count} occurrence(s) of '{minority_term}' with '{majority_term}'.",
                'can_auto_fix': True,
                'auto_fix_data': {
                    'find': minority_term,
                    'replace': majority_term,
                    'count': minority_count
                },
                'details': {
                    'majority_term': majority_term,
                    'majority_count': majority_count,
                    'minority_term': minority_term,
                    'minority_count': minority_count
                }
            })
    
    return issues


def detect_all_abbreviation_issues(text: str) -> List[Dict]:
    """
    Main entry point for abbreviation detection.
    
    DETERMINISTIC: Same text â†’ Same issues (always)
    """
    return detect_abbreviation_issues(text)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

DO NOT TOUCH:
- Any other files (registration will be done in REPLIT-7#10)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VERIFICATION:

Test input:
"I work with AI and Machine Learning. AI is great. AI helps. 
Also used Artificial Intelligence once."

Expected output:
- 1 issue: FORMAT_INCONSISTENT_ABBREVIATION
- match_text: "Artificial Intelligence"
- suggestion: Replace 1 occurrence with "AI"
- majority: AI (3 times)
- minority: Artificial Intelligence (1 time)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

WHEN COMPLETE:

Confirm:
â–¡ abbreviation_detector.py created
â–¡ ABBREVIATION_PAIRS list includes common tech terms
â–¡ detect_abbreviation_issues returns issues for minority form only
â–¡ auto_fix_data included for auto-fix support
â–¡ No Python syntax errors

Type "REPLIT-3#10 COMPLETE - READY FOR NEXT" when done.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•