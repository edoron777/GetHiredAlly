═══════════════════════════════════════════════════════════════
PROMPT 2#6: Create Main Calculator Function
═══════════════════════════════════════════════════════════════

⚠️ CRITICAL COMPLIANCE REQUIREMENTS ⚠️

1. Execute ONLY the instructions below - nothing more
2. Do NOT modify files not explicitly mentioned
3. Do NOT add features not explicitly requested
4. Do NOT refactor or "improve" existing code
5. If unclear, STOP and ask - do not assume

FORBIDDEN ACTIONS:
- Modifying config.py
- Adding new dependencies
- Creating additional files

───────────────────────────────────────────────────────────────

TASK: Create the main calculator function and pattern matcher

OBJECTIVE:
Implement the core scoring calculation that combines all category scores into a final deterministic score.

CONTEXT:
This calculator will be the central function that receives extracted CV data and returns a deterministic score.

───────────────────────────────────────────────────────────────

INSTRUCTIONS:

Step 1: Create `server/common/scoring/calculator.py` with:
```python
"""
Main CV Score Calculator - DETERMINISTIC
Version: 4.0

CRITICAL: Same input MUST produce same output EVERY TIME.
No randomness, no AI interpretation in scoring.
"""

from dataclasses import dataclass
from typing import Dict, List, Any, Optional

from .config import (
    CATEGORY_WEIGHTS,
    SCORE_MIN,
    SCORE_MAX,
    GRADE_THRESHOLDS
)
from .categories import (
    score_content_quality,
    score_language_clarity,
    score_formatting,
    score_completeness,
    score_professional,
    score_red_flags
)


@dataclass
class ScoreResult:
    """Result of CV score calculation."""
    total_score: int
    breakdown: Dict[str, float]
    grade: str
    grade_label: str
    issues_count: int
    auto_fixable_count: int


def calculate_cv_score(extracted_data: Dict[str, Any]) -> ScoreResult:
    """
    Calculate CV score from extracted data.
    
    DETERMINISTIC: Same input = Same output, ALWAYS.
    
    Args:
        extracted_data: Dictionary containing structured CV data
                       (from AI extraction or pattern matching)
    
    Returns:
        ScoreResult with total score, breakdown, and grade
    """
    breakdown = {}
    
    # Calculate each category score
    breakdown['content_quality'] = score_content_quality(extracted_data)
    breakdown['language_clarity'] = score_language_clarity(extracted_data)
    breakdown['formatting'] = score_formatting(extracted_data)
    breakdown['completeness'] = score_completeness(extracted_data)
    breakdown['professional'] = score_professional(extracted_data)
    breakdown['red_flags'] = score_red_flags(extracted_data)
    
    # Calculate total (sum of all categories)
    total = sum(breakdown.values())
    
    # Apply bounds
    total = max(SCORE_MIN, min(SCORE_MAX, total))
    
    # Get grade
    grade, grade_label = get_grade(total)
    
    # Count issues
    issues = extracted_data.get('issues', [])
    issues_count = len(issues)
    auto_fixable_count = sum(1 for i in issues if i.get('is_auto_fixable', False))
    
    return ScoreResult(
        total_score=round(total),
        breakdown={k: round(v, 1) for k, v in breakdown.items()},
        grade=grade,
        grade_label=grade_label,
        issues_count=issues_count,
        auto_fixable_count=auto_fixable_count
    )


def get_grade(score: float) -> tuple:
    """
    Convert numeric score to grade.
    
    Returns:
        Tuple of (grade_key, grade_label)
    """
    if score >= GRADE_THRESHOLDS['excellent']:
        return ('excellent', 'Excellent')
    elif score >= GRADE_THRESHOLDS['good']:
        return ('good', 'Good')
    elif score >= GRADE_THRESHOLDS['fair']:
        return ('fair', 'Fair')
    elif score >= GRADE_THRESHOLDS['needs_work']:
        return ('needs_work', 'Needs Work')
    else:
        return ('poor', 'Poor')


def get_score_message(score: int) -> str:
    """
    Get user-friendly message for score.
    
    Args:
        score: Total CV score (0-100)
    
    Returns:
        Encouraging message appropriate for score level
    """
    if score >= 90:
        return "Outstanding! Your CV is highly polished and job-ready."
    elif score >= 80:
        return "Great CV! Minor polish will make it perfect."
    elif score >= 70:
        return "Good foundation! A few improvements will help you stand out."
    elif score >= 60:
        return "Decent CV. Several improvements recommended."
    elif score >= 50:
        return "Your CV needs attention in multiple areas."
    else:
        return "Significant improvements needed. Focus on critical issues first."


def calculate_improvement(before_score: int, after_score: int) -> Dict[str, Any]:
    """
    Calculate improvement between before and after scores.
    
    Args:
        before_score: Original CV score
        after_score: Fixed CV score
    
    Returns:
        Dictionary with improvement details
    """
    improvement = after_score - before_score
    improvement_percent = round((improvement / max(before_score, 1)) * 100)
    
    return {
        'before_score': before_score,
        'after_score': after_score,
        'improvement_points': improvement,
        'improvement_percent': improvement_percent
    }
```

Step 2: Create `server/common/scoring/extractors/pattern_matcher.py` with:
```python
"""
Pattern Matcher - Deterministic regex-based detection
Version: 4.0

All pattern matching is DETERMINISTIC - same text = same results.
"""

import re
from typing import List, Dict, Any


class PatternMatcher:
    """Deterministic pattern detection for CV analysis."""
    
    # Regex patterns for detection
    PATTERNS = {
        # Contact information
        'email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
        'phone': r'\+?\d{1,3}[-.\s]?\(?\d{2,3}\)?[-.\s]?\d{3}[-.\s]?\d{4}',
        'linkedin': r'linkedin\.com/in/[\w-]+',
        'github': r'github\.com/[\w-]+',
        
        # Quantification
        'percentage': r'\d+%',
        'currency': r'\$[\d,]+[KMB]?',
        'team_size': r'team of \d+|\d+\s*(team members|engineers|developers|people|reports)',
        'time_metric': r'\d+\s*(months?|years?|weeks?|days?)',
        'project_count': r'\d+\s*projects?',
        'user_count': r'\d+[,\d]*\s*(users?|customers?|clients?|patients?|students?)',
        'any_number': r'\b\d+\b',
        
        # Structure
        'section_header': r'^(About|Summary|Profile|Experience|Work Experience|Education|Skills|Technical Skills|Certifications|Projects|Awards|Languages|Interests)',
        'bullet_point': r'^[\•\-\*\○\►]\s',
        'date_format': r'\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s+\d{4}\b|\b\d{1,2}/\d{4}\b|\b\d{4}\s*[-–]\s*(Present|\d{4})\b',
        
        # Red flags
        'unprofessional_email': r'(sexy|hot|babe|party|420|princess|gangster|killer|xoxo|cutie|lover|ninja|pimp)\d*@',
        'personal_info': r'\b(age|date of birth|dob|marital status|religion|nationality)\b',
        'salary_mention': r'\$([\d,]+)\s*(per|/)\s*(year|month|hour|annum)|salary|compensation',
    }
    
    @classmethod
    def find_all(cls, pattern_name: str, text: str) -> List[str]:
        """
        Find all matches for a named pattern.
        
        DETERMINISTIC: Same text = Same results.
        
        Args:
            pattern_name: Key from PATTERNS dict
            text: Text to search
        
        Returns:
            List of all matches
        """
        pattern = cls.PATTERNS.get(pattern_name)
        if not pattern:
            return []
        return re.findall(pattern, text, re.IGNORECASE | re.MULTILINE)
    
    @classmethod
    def count(cls, pattern_name: str, text: str) -> int:
        """
        Count matches for a pattern.
        
        DETERMINISTIC: Same text = Same count.
        """
        return len(cls.find_all(pattern_name, text))
    
    @classmethod
    def has_match(cls, pattern_name: str, text: str) -> bool:
        """
        Check if pattern exists in text.
        
        DETERMINISTIC: Same text = Same boolean.
        """
        return cls.count(pattern_name, text) > 0
    
    @classmethod
    def count_words(cls, text: str) -> int:
        """Count words in text. DETERMINISTIC."""
        return len(text.split())
    
    @classmethod
    def count_bullets(cls, text: str) -> int:
        """Count bullet points. DETERMINISTIC."""
        # Count lines starting with bullet characters
        lines = text.split('\n')
        count = 0
        for line in lines:
            stripped = line.strip()
            if stripped and stripped[0] in '•-*○►':
                count += 1
        return count
    
    @classmethod
    def find_word_frequency(cls, text: str, min_count: int = 5) -> Dict[str, int]:
        """
        Find words that appear frequently.
        
        Args:
            text: Text to analyze
            min_count: Minimum occurrences to include
        
        Returns:
            Dictionary of word -> count for frequent words
        """
        # Simple word extraction
        words = re.findall(r'\b[a-zA-Z]{4,}\b', text.lower())
        
        # Count occurrences
        freq = {}
        for word in words:
            freq[word] = freq.get(word, 0) + 1
        
        # Filter by min_count
        return {w: c for w, c in freq.items() if c >= min_count}
    
    @classmethod
    def check_verb_at_start(cls, bullet_text: str, verb_list: List[str]) -> bool:
        """
        Check if bullet starts with a verb from the list.
        
        DETERMINISTIC.
        """
        # Get first word
        words = bullet_text.strip().split()
        if not words:
            return False
        
        first_word = words[0].strip('•-*○► ').capitalize()
        return first_word in verb_list
    
    @classmethod
    def extract_all_metrics(cls, text: str) -> Dict[str, List[str]]:
        """
        Extract all quantification metrics from text.
        
        Returns:
            Dictionary with metric types and their values
        """
        return {
            'percentages': cls.find_all('percentage', text),
            'currency': cls.find_all('currency', text),
            'team_sizes': cls.find_all('team_size', text),
            'time_metrics': cls.find_all('time_metric', text),
            'project_counts': cls.find_all('project_count', text),
            'user_counts': cls.find_all('user_count', text)
        }
```

───────────────────────────────────────────────────────────────

FILES TO CREATE:
- server/common/scoring/calculator.py
- server/common/scoring/extractors/pattern_matcher.py

FILES TO MODIFY:
- None

DO NOT TOUCH:
- server/common/scoring/config.py (already created)
- All other files

───────────────────────────────────────────────────────────────

WHEN COMPLETE:

Confirm these items:
□ calculator.py created with ScoreResult dataclass
□ calculate_cv_score function implemented
□ pattern_matcher.py created with PatternMatcher class
□ All regex patterns defined
□ No syntax errors
□ No other files modified

Report any issues or uncertainties.