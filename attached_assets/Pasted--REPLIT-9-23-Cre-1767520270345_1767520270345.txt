â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’» REPLIT-9#23: Create Length Handler
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILE: backend/common/detection/rule_engine/handlers/length_handler.py
```python
"""
Length Handler

Detects issues based on text length (words, characters, sentences).

detection_config format:
{
    "type": "length",
    "target": "summary",  // What to measure
    "unit": "words",  // "words", "characters", "sentences", "lines"
    "min_length": 30,
    "max_length": 100,
    "issue_when": "outside_range"  // "below_min", "above_max", "outside_range"
}
"""

import re
import logging
from typing import List

from .base import BaseHandler, DetectedIssue
from backend.common.detection.section_extractor import CVStructure
from ..cache import DetectionRule

logger = logging.getLogger(__name__)


class LengthHandler(BaseHandler):
    """
    Handler for length-based detection.
    """
    
    def detect(
        self, 
        cv_text: str, 
        cv_structure: CVStructure, 
        rule: DetectionRule
    ) -> List[DetectedIssue]:
        """
        Detect length-based issues.
        """
        issues = []
        config = rule.detection_config
        
        # Get configuration
        target = config.get('target', 'cv')
        unit = config.get('unit', 'words')
        min_length = config.get('min_length')
        max_length = config.get('max_length')
        issue_when = config.get('issue_when', 'outside_range')
        
        # Get target text
        text = self.get_target_text(cv_structure, target)
        if not text and min_length:
            # Empty section is below minimum
            issue = self.create_issue(
                rule=rule,
                match_text=f"{target} section is empty",
                location=target,
                details={'length': 0, 'unit': unit}
            )
            issues.append(issue)
            return issues
        
        # Measure length
        length = self._measure_length(text, unit)
        
        # Check thresholds
        below_min = min_length is not None and length < min_length
        above_max = max_length is not None and length > max_length
        
        should_trigger = (
            (issue_when == 'below_min' and below_min) or
            (issue_when == 'above_max' and above_max) or
            (issue_when == 'outside_range' and (below_min or above_max))
        )
        
        if should_trigger:
            if below_min:
                match_text = f"{target} has {length} {unit} (minimum: {min_length})"
            else:
                match_text = f"{target} has {length} {unit} (maximum: {max_length})"
            
            issue = self.create_issue(
                rule=rule,
                match_text=match_text,
                location=target,
                details={
                    'length': length,
                    'unit': unit,
                    'min_length': min_length,
                    'max_length': max_length,
                    'target': target
                }
            )
            issues.append(issue)
        
        return issues
    
    def _measure_length(self, text: str, unit: str) -> int:
        """Measure text length in different units."""
        if not text:
            return 0
        
        if unit == 'words':
            return len(text.split())
        
        elif unit == 'characters':
            return len(text)
        
        elif unit == 'sentences':
            # Simple sentence count
            return len(re.findall(r'[.!?]+', text))
        
        elif unit == 'lines':
            return len([l for l in text.split('\n') if l.strip()])
        
        else:
            return len(text.split())
```

UPDATE __init__.py: Add `from .length_handler import LengthHandler`

Type "REPLIT-9#23 COMPLETE" when done.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•