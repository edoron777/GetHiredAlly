â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
IMPLEMENTATION PROMPT: UserSessionKeep Reusable Function
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GOAL:
Create a reusable component called "UserSessionKeep" that shows a "Continue 
your work" banner when user has an existing session in any service.

PRINCIPLES:
1. DRY - Don't Repeat Yourself (one component, used everywhere)
2. Separation - Code lives in its own folder
3. Consistency - Same look and feel across all services

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 1: CREATE COMPONENT FILES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Create folder: client/src/components/common/UserSessionKeep/

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE 1: sessionTypes.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
````typescript
// client/src/components/common/UserSessionKeep/sessionTypes.ts

export interface ServiceSessionData {
  id: string | number;
  serviceName: string;
  displayTitle: string;
  summary: string;
  updatedAt: string;
  status: 'completed' | 'in_progress' | 'pending';
  continueUrl: string;
  metadata?: Record<string, any>;
}

export interface ServiceConfig {
  serviceName: string;
  displayName: string;
  apiEndpoint: string;
  archiveEndpoint: string;
  getContinueUrl: (id: string | number) => string;
  formatSummary: (data: any) => string;
}

export const SERVICE_CONFIGS: Record<string, ServiceConfig> = {
  'cv-optimizer': {
    serviceName: 'cv-optimizer',
    displayName: 'Perfect Your CV',
    apiEndpoint: '/api/cv-optimizer/latest',
    archiveEndpoint: '/api/cv-optimizer/scans',
    getContinueUrl: (id) => `/service/cv-optimizer/crossroads/${id}`,
    formatSummary: (data) => 
      `Score: ${data.score || 0}% â€¢ ${data.total_issues || 0} issues found`
  },
  'xray-analyzer': {
    serviceName: 'xray-analyzer',
    displayName: 'Decode the Job Post',
    apiEndpoint: '/api/xray/latest',
    archiveEndpoint: '/api/xray/sessions',
    getContinueUrl: (id) => `/service/understand-job/results/${id}`,
    formatSummary: (data) => 
      `${data.job_title || 'Job Analysis'} at ${data.company_name || 'Company'}`
  },
  'predict-questions': {
    serviceName: 'predict-questions',
    displayName: 'Predict the Questions',
    apiEndpoint: '/api/smart-questions/latest',
    archiveEndpoint: '/api/smart-questions/results',
    getContinueUrl: (id) => `/service/predict-questions/smart/results/${id}`,
    formatSummary: (data) => 
      `${data.question_count || 0} questions predicted`
  }
};
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE 2: useServiceSession.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
````typescript
// client/src/components/common/UserSessionKeep/useServiceSession.ts

import { useState, useEffect, useCallback } from 'react';
import { ServiceSessionData, SERVICE_CONFIGS } from './sessionTypes';
import { getAuthToken } from '../../../lib/auth';

interface UseServiceSessionResult {
  session: ServiceSessionData | null;
  isLoading: boolean;
  error: string | null;
  archiveSession: () => Promise<boolean>;
  refreshSession: () => Promise<void>;
}

export function useServiceSession(serviceName: string): UseServiceSessionResult {
  const [session, setSession] = useState<ServiceSessionData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const config = SERVICE_CONFIGS[serviceName];

  const fetchSession = useCallback(async () => {
    if (!config) {
      setError(`Unknown service: ${serviceName}`);
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      const token = getAuthToken();
      
      const response = await fetch(`${config.apiEndpoint}?token=${token}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        if (response.status === 404) {
          // No existing session - this is fine
          setSession(null);
          return;
        }
        throw new Error('Failed to fetch session');
      }

      const data = await response.json();
      
      if (data && data.id) {
        setSession({
          id: data.id,
          serviceName: config.serviceName,
          displayTitle: config.displayName,
          summary: config.formatSummary(data),
          updatedAt: data.updated_at || data.created_at,
          status: data.status || 'completed',
          continueUrl: config.getContinueUrl(data.id),
          metadata: data
        });
      } else {
        setSession(null);
      }
    } catch (err) {
      console.error('Error fetching session:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
      setSession(null);
    } finally {
      setIsLoading(false);
    }
  }, [serviceName, config]);

  const archiveSession = useCallback(async (): Promise<boolean> => {
    if (!session || !config) return false;

    try {
      const token = getAuthToken();
      const response = await fetch(
        `${config.archiveEndpoint}/${session.id}/archive?token=${token}`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );

      if (response.ok) {
        setSession(null);
        return true;
      }
      return false;
    } catch (err) {
      console.error('Error archiving session:', err);
      return false;
    }
  }, [session, config]);

  useEffect(() => {
    fetchSession();
  }, [fetchSession]);

  return {
    session,
    isLoading,
    error,
    archiveSession,
    refreshSession: fetchSession
  };
}
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE 3: UserSessionKeep.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
````tsx
// client/src/components/common/UserSessionKeep/UserSessionKeep.tsx

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useServiceSession } from './useServiceSession';
import { ServiceSessionData } from './sessionTypes';

interface UserSessionKeepProps {
  serviceName: string;
  onStartNew?: () => void;
}

interface ConfirmDialogProps {
  isOpen: boolean;
  session: ServiceSessionData;
  onCancel: () => void;
  onConfirm: () => void;
  onDownload?: () => void;
}

// Confirmation Dialog Component
const ConfirmDialog: React.FC<ConfirmDialogProps> = ({
  isOpen,
  session,
  onCancel,
  onConfirm,
  onDownload
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">
          âš ï¸ Start New Analysis?
        </h3>
        <p className="text-gray-600 mb-4">
          This will clear your current work:
        </p>
        <div className="bg-gray-50 rounded p-3 mb-4">
          <p className="font-medium text-gray-900">{session.displayTitle}</p>
          <p className="text-sm text-gray-500">{session.summary}</p>
        </div>
        <p className="text-sm text-gray-500 mb-6">
          You can download your results before starting over.
        </p>
        <div className="flex gap-3 justify-end flex-wrap">
          <button
            onClick={onCancel}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors"
          >
            Cancel
          </button>
          {onDownload && (
            <button
              onClick={onDownload}
              className="px-4 py-2 border border-blue-300 text-blue-600 rounded-lg hover:bg-blue-50 transition-colors"
            >
              Download Results
            </button>
          )}
          <button
            onClick={onConfirm}
            className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
          >
            Start New
          </button>
        </div>
      </div>
    </div>
  );
};

// Time ago formatter
const formatTimeAgo = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
  if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
  return date.toLocaleDateString();
};

// Main Component
export const UserSessionKeep: React.FC<UserSessionKeepProps> = ({
  serviceName,
  onStartNew
}) => {
  const { session, isLoading, archiveSession } = useServiceSession(serviceName);
  const [showConfirm, setShowConfirm] = useState(false);

  // Don't show anything while loading or if no session
  if (isLoading || !session) {
    return null;
  }

  const handleStartNew = async () => {
    const success = await archiveSession();
    if (success) {
      setShowConfirm(false);
      onStartNew?.();
    }
  };

  const handleDownload = () => {
    // Open export in new tab - service-specific URL
    const exportUrl = `${session.metadata?.exportUrl || '#'}`;
    if (exportUrl !== '#') {
      window.open(exportUrl, '_blank');
    }
  };

  return (
    <>
      {/* Continue Banner */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
        <div className="flex items-center justify-between flex-wrap gap-4">
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-blue-900 flex items-center gap-2">
              ğŸ“„ You have work in progress
            </h3>
            <p className="text-sm text-blue-700 mt-1 truncate">
              {session.summary}
            </p>
            <p className="text-xs text-blue-500 mt-1">
              Last updated: {formatTimeAgo(session.updatedAt)}
            </p>
          </div>
          <div className="flex gap-3">
            <Link
              to={session.continueUrl}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium"
            >
              Continue
            </Link>
            <button
              onClick={() => setShowConfirm(true)}
              className="bg-white text-blue-600 border border-blue-300 px-4 py-2 rounded-lg hover:bg-blue-50 transition-colors font-medium"
            >
              Start New
            </button>
          </div>
        </div>
      </div>

      {/* Confirmation Dialog */}
      <ConfirmDialog
        isOpen={showConfirm}
        session={session}
        onCancel={() => setShowConfirm(false)}
        onConfirm={handleStartNew}
        onDownload={session.metadata?.exportUrl ? handleDownload : undefined}
      />
    </>
  );
};

export default UserSessionKeep;
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE 4: index.ts
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
````typescript
// client/src/components/common/UserSessionKeep/index.ts

export { UserSessionKeep, default } from './UserSessionKeep';
export { useServiceSession } from './useServiceSession';
export { SERVICE_CONFIGS } from './sessionTypes';
export type { ServiceSessionData, ServiceConfig } from './sessionTypes';
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 2: UPDATE COMPONENT REGISTRY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILE: client/src/components/common/index.ts

ADD this export:
````typescript
// Add to existing exports
export { UserSessionKeep, useServiceSession, SERVICE_CONFIGS } from './UserSessionKeep';
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 3: BACKEND API ENDPOINTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The component needs these endpoints for each service.
CV Optimizer already has them. Add for other services:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: backend/app/analyze.py (X-Ray Analyzer)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ADD these endpoints:
````python
@router.get("/api/xray/latest")
async def get_latest_xray_session(
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """Get the most recent completed X-Ray analysis for current user"""
    user = await get_user_from_token(token, db)
    if not user:
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    # Query for latest completed session
    session = db.query(AnalysisSession).filter(
        AnalysisSession.user_id == user.id,
        AnalysisSession.status.in_(['completed', 'in_progress'])
    ).order_by(AnalysisSession.created_at.desc()).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="No session found")
    
    return {
        "id": session.id,
        "job_title": session.job_title,
        "company_name": session.company_name,
        "status": session.status,
        "created_at": session.created_at.isoformat(),
        "updated_at": session.updated_at.isoformat() if session.updated_at else session.created_at.isoformat()
    }


@router.post("/api/xray/sessions/{session_id}/archive")
async def archive_xray_session(
    session_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """Archive an X-Ray session"""
    user = await get_user_from_token(token, db)
    if not user:
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    session = db.query(AnalysisSession).filter(
        AnalysisSession.id == session_id,
        AnalysisSession.user_id == user.id
    ).first()
    
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    session.status = 'archived'
    db.commit()
    
    return {"success": True, "message": "Session archived"}
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: backend/app/smart_questions.py (Predict Questions)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ADD these endpoints:
````python
@router.get("/api/smart-questions/latest")
async def get_latest_smart_questions(
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """Get the most recent smart questions result for current user"""
    user = await get_user_from_token(token, db)
    if not user:
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    result = db.query(SmartQuestionResult).filter(
        SmartQuestionResult.user_id == user.id,
        SmartQuestionResult.status.in_(['completed', 'in_progress'])
    ).order_by(SmartQuestionResult.created_at.desc()).first()
    
    if not result:
        raise HTTPException(status_code=404, detail="No results found")
    
    # Count questions
    questions = result.personalized_questions or []
    question_count = len(questions) if isinstance(questions, list) else 0
    
    return {
        "id": result.id,
        "job_title": result.job_title,
        "question_count": question_count,
        "status": result.status,
        "created_at": result.created_at.isoformat(),
        "updated_at": result.updated_at.isoformat() if result.updated_at else result.created_at.isoformat()
    }


@router.post("/api/smart-questions/results/{result_id}/archive")
async def archive_smart_questions(
    result_id: int,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """Archive a smart questions result"""
    user = await get_user_from_token(token, db)
    if not user:
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    result = db.query(SmartQuestionResult).filter(
        SmartQuestionResult.id == result_id,
        SmartQuestionResult.user_id == user.id
    ).first()
    
    if not result:
        raise HTTPException(status_code=404, detail="Result not found")
    
    result.status = 'archived'
    db.commit()
    
    return {"success": True, "message": "Result archived"}
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 4: ADD STATUS COLUMN (IF MISSING)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Check if tables have 'status' column. If not, add migration:
````sql
-- For analysis_sessions (X-Ray)
ALTER TABLE analysis_sessions 
ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'completed';

-- For smart_question_results (Predict Questions)
ALTER TABLE smart_question_results 
ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'completed';
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 5: INTEGRATE INTO SERVICE PAGES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: client/src/components/CVOptimizerPage.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

REPLACE existing "Continue Analysis" banner with UserSessionKeep:
````tsx
import { UserSessionKeep } from './common/UserSessionKeep';

// In the component render:
<UserSessionKeep 
  serviceName="cv-optimizer"
  onStartNew={() => {
    // Optional: Reset any local state
  }}
/>
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: client/src/components/UnderstandJobPage.tsx (X-Ray)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ADD UserSessionKeep at the top of the page:
````tsx
import { UserSessionKeep } from './common/UserSessionKeep';

// In the component render, add before the main content:
<UserSessionKeep 
  serviceName="xray-analyzer"
  onStartNew={() => {
    // Optional: Reset any local state
  }}
/>
````

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: client/src/components/QuestionsServicePage.tsx or SmartQuestionsPage.tsx
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ADD UserSessionKeep at the top of the page:
````tsx
import { UserSessionKeep } from './common/UserSessionKeep';

// In the component render, add before the main content:
<UserSessionKeep 
  serviceName="predict-questions"
  onStartNew={() => {
    // Optional: Reset any local state
  }}
/>
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 6: CREATE DOCUMENTATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE FILE: client/src/components/common/UserSessionKeep/README.md
````markdown
# UserSessionKeep Component

## Purpose
Displays a "Continue your work" banner when user has an existing session in any service.
Provides consistent UX across all GetHiredAlly services.

## Usage
```tsx
import { UserSessionKeep } from '../common/UserSessionKeep';

<UserSessionKeep 
  serviceName="cv-optimizer"
  onStartNew={() => console.log('Starting new')}
/>
```

## Supported Services

| Service Name | Display Name | API Endpoint |
|--------------|--------------|--------------|
| cv-optimizer | Perfect Your CV | /api/cv-optimizer/latest |
| xray-analyzer | Decode the Job Post | /api/xray/latest |
| predict-questions | Predict the Questions | /api/smart-questions/latest |

## Adding New Services

1. Add config to `sessionTypes.ts` SERVICE_CONFIGS
2. Create backend `/api/{service}/latest` endpoint
3. Create backend `/api/{service}/{id}/archive` endpoint
4. Import and use UserSessionKeep in service page

## Props

| Prop | Type | Required | Description |
|------|------|----------|-------------|
| serviceName | string | Yes | Key from SERVICE_CONFIGS |
| onStartNew | () => void | No | Callback after archive |

## Hooks

### useServiceSession(serviceName)

Returns:
- `session`: Current session data or null
- `isLoading`: Loading state
- `error`: Error message or null
- `archiveSession`: Function to archive current session
- `refreshSession`: Function to re-fetch session
````

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERIFICATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TEST 1: CV Optimizer
1. Go to /service/cv-optimizer
2. Upload and analyze a CV
3. Go to Home
4. Return to /service/cv-optimizer
5. âœ“ Banner shows "Continue" option

TEST 2: X-Ray Analyzer
1. Go to /service/understand-job
2. Analyze a job description
3. Go to Home
4. Return to /service/understand-job
5. âœ“ Banner shows "Continue" option

TEST 3: Predict Questions
1. Go to /service/predict-questions
2. Generate questions
3. Go to Home
4. Return to /service/predict-questions
5. âœ“ Banner shows "Continue" option

TEST 4: Start New Confirmation
1. Have existing session
2. Click "Start New"
3. âœ“ Confirmation dialog appears
4. Click "Start New" in dialog
5. âœ“ Session archived, banner disappears

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
REPORT FORMAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PART 1 (Component Files):
- sessionTypes.ts created: YES/NO
- useServiceSession.ts created: YES/NO
- UserSessionKeep.tsx created: YES/NO
- index.ts created: YES/NO

PART 2 (Component Registry):
- Export added to common/index.ts: YES/NO

PART 3 (Backend APIs):
- X-Ray /latest endpoint: YES/NO
- X-Ray /archive endpoint: YES/NO
- Predict Questions /latest endpoint: YES/NO
- Predict Questions /archive endpoint: YES/NO

PART 4 (Database):
- Status column added if needed: YES/NO

PART 5 (Integration):
- CVOptimizerPage updated: YES/NO
- UnderstandJobPage updated: YES/NO
- QuestionsServicePage updated: YES/NO

PART 6 (Documentation):
- README.md created: YES/NO

VERIFICATION:
- Test 1 (CV Optimizer): PASS/FAIL
- Test 2 (X-Ray): PASS/FAIL
- Test 3 (Predict Questions): PASS/FAIL
- Test 4 (Start New): PASS/FAIL

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•