# Security Prompt 1: SQL Audit + Input Validation

**Task:** Audit all SQL queries and add input validation to all API endpoints
**Priority:** üî¥ P1 - CRITICAL
**Estimated Effort:** 6-8 hours

---

## ‚ö†Ô∏è CRITICAL INSTRUCTIONS

- This is a SECURITY task - follow instructions exactly
- Do NOT skip any endpoint
- Do NOT leave any SQL query unchecked

---

## PART A: SQL Query Audit

### Task

Find ALL database queries in the codebase and verify they use parameterized queries.

### What to Look For

**Search for these patterns:**

```python
# DANGEROUS - SQL Injection vulnerable
f"SELECT * FROM users WHERE email = '{email}'"
f"INSERT INTO users VALUES ('{name}', '{email}')"
"SELECT * FROM users WHERE id = " + user_id
```

### How to Fix

**Convert to parameterized queries:**

```python
# SAFE - Parameterized query
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
cursor.execute("INSERT INTO users VALUES (%s, %s)", (name, email))
```

**Supabase client (already safe):**
```python
# Supabase handles parameterization - this is SAFE
supabase.table('users').select('*').eq('email', email).execute()
```

### Audit Checklist

Check these files/areas:
- [ ] User authentication (login, register, password reset)
- [ ] User profile (get, update)
- [ ] CV upload/retrieve
- [ ] Job description storage
- [ ] X-Ray report storage/retrieval
- [ ] Questions storage/retrieval
- [ ] Smart questions storage/retrieval
- [ ] Any admin queries

### Report Format

After audit, create a comment or log:
```
SQL AUDIT COMPLETE:
- Total queries found: XX
- Already parameterized: XX
- Fixed: XX
- Files modified: [list files]
```

---

## PART B: Input Validation

### Task

Add Pydantic validation models to ALL API endpoints that accept user input.

### Validation Rules

| Field Type | Validation |
|------------|------------|
| Email | Must be valid email format (use `EmailStr`) |
| Password | Min 8 chars, max 128 chars |
| Name | Min 1 char, max 100 chars, sanitize HTML |
| Job Description | Max 50,000 chars |
| CV Text | Max 100,000 chars |
| File Upload | Max 10MB, allowed extensions only |
| IDs | Must be valid UUID or integer |
| URLs | Must be valid URL format |

### Implementation

**Step 1: Create validation models file**

```python
# validators/input_models.py

from pydantic import BaseModel, Field, EmailStr, validator
import re

class UserRegisterInput(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=8, max_length=128)
    name: str = Field(..., min_length=1, max_length=100)
    
    @validator('name')
    def sanitize_name(cls, v):
        # Remove HTML tags
        return re.sub(r'<[^>]*>', '', v).strip()

class UserLoginInput(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=1, max_length=128)

class JobDescriptionInput(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    company: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=10, max_length=50000)
    
    @validator('title', 'company')
    def sanitize_text(cls, v):
        return re.sub(r'<[^>]*>', '', v).strip()

class CVInput(BaseModel):
    content: str = Field(..., min_length=10, max_length=100000)

class SmartQuestionsInput(BaseModel):
    job_description_id: int = Field(..., gt=0)
    cv_id: int = Field(..., gt=0)

class XRayInput(BaseModel):
    job_description: str = Field(..., min_length=10, max_length=50000)
    interviewer_type: str = Field(default="hiring_manager")
    depth_level: str = Field(default="standard")
    
    @validator('interviewer_type')
    def validate_interviewer_type(cls, v):
        allowed = ['hiring_manager', 'recruiter', 'technical', 'executive']
        if v not in allowed:
            raise ValueError(f'Must be one of: {allowed}')
        return v
    
    @validator('depth_level')
    def validate_depth_level(cls, v):
        allowed = ['quick', 'standard', 'detailed', 'comprehensive']
        if v not in allowed:
            raise ValueError(f'Must be one of: {allowed}')
        return v
```

**Step 2: Apply to API endpoints**

```python
# In your API routes

from validators.input_models import UserRegisterInput, UserLoginInput, JobDescriptionInput

@app.post("/api/auth/register")
async def register(user_input: UserRegisterInput):
    # Input is already validated by Pydantic
    email = user_input.email
    password = user_input.password
    name = user_input.name
    # ... rest of logic

@app.post("/api/auth/login")
async def login(user_input: UserLoginInput):
    # Input is already validated
    # ... rest of logic

@app.post("/api/xray/generate")
async def generate_xray(xray_input: XRayInput):
    # Input is already validated
    # ... rest of logic
```

**Step 3: File upload validation**

```python
# validators/file_validators.py

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'txt'}

async def validate_file_upload(file: UploadFile):
    # Check extension
    filename = file.filename or ""
    extension = filename.split('.')[-1].lower() if '.' in filename else ''
    
    if extension not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400, 
            detail=f"Invalid file type. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
        )
    
    # Check size
    content = await file.read()
    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=400,
            detail=f"File too large. Maximum size: {MAX_FILE_SIZE // (1024*1024)}MB"
        )
    
    # Reset file position for later reading
    await file.seek(0)
    
    return content
```

### Endpoints Checklist

Add validation to ALL these endpoints:

**Authentication:**
- [ ] POST /api/auth/register
- [ ] POST /api/auth/login
- [ ] POST /api/auth/forgot-password
- [ ] POST /api/auth/reset-password
- [ ] POST /api/auth/verify-email

**User:**
- [ ] PUT /api/user/profile
- [ ] PUT /api/user/password

**CV:**
- [ ] POST /api/cv/upload
- [ ] PUT /api/cv/{id}

**Job Description:**
- [ ] POST /api/job-description
- [ ] PUT /api/job-description/{id}

**X-Ray:**
- [ ] POST /api/xray/generate

**Questions:**
- [ ] POST /api/questions/smart/generate

**Any other endpoints accepting user input**

---

## VERIFICATION CHECKLIST

After implementation:

- [ ] All SQL queries are parameterized (no string concatenation)
- [ ] All API endpoints have Pydantic input models
- [ ] Email fields use `EmailStr`
- [ ] All text fields have max_length limits
- [ ] File uploads validate size and extension
- [ ] HTML tags are stripped from text inputs
- [ ] Enum fields validate against allowed values
- [ ] Error messages are user-friendly (no internal details)

---

## TESTING

Test each endpoint with:

1. **Valid input** - Should work normally
2. **Too long input** - Should return 422 error
3. **Invalid email** - Should return 422 error
4. **SQL injection attempt** - Should be harmless
   ```
   email: "test@test.com'; DROP TABLE users; --"
   ```
5. **XSS attempt** - Should be sanitized
   ```
   name: "<script>alert('xss')</script>John"
   ```

---

**END OF PROMPT**