â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’» REPLIT-2#23: Create Rule Loader (CatalogService Pattern)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ ANTI-IMPROVISATION DIRECTIVE:
- FOLLOW the CatalogService pattern EXACTLY
- Look at backend/common/catalog/ for reference
- Use SAME Supabase connection pattern
- If unclear â†’ STOP and ask

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TASK: Implement RuleLoader following the CatalogService singleton pattern.

REFERENCE FILES (read these first):
- backend/common/catalog/service.py â†’ CatalogService
- backend/common/catalog/repository.py â†’ CatalogRepository  
- backend/common/catalog/cache.py â†’ CatalogCache

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE 1: backend/common/detection/rule_engine/repository.py
```python
"""
Rule Repository

Database queries for detection rules.
FOLLOWS: CatalogRepository pattern from common/catalog/repository.py
"""

import logging
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)


class RuleRepository:
    """
    Database access for detection rules.
    
    Uses v_cv_detection_rules view created in DB-1.
    """
    
    def __init__(self, supabase_client=None):
        """
        Initialize repository.
        
        Args:
            supabase_client: Supabase client. If None, will get from environment.
        """
        self._client = supabase_client
        self._initialized = False
    
    def _get_client(self):
        """Get Supabase client (lazy initialization)."""
        if self._client is None:
            # Follow same pattern as CatalogRepository
            try:
                from common.services.supabase_client import get_supabase_client
                self._client = get_supabase_client()
            except ImportError:
                # Alternative import path
                from backend.common.services.supabase_client import get_supabase_client
                self._client = get_supabase_client()
        return self._client
    
    def fetch_all_detection_rules(self) -> List[Dict[str, Any]]:
        """
        Fetch all detection rules with non-empty detection_config.
        
        Returns:
            List of rule dictionaries from v_cv_detection_rules view
        """
        try:
            client = self._get_client()
            
            response = client.from_('v_cv_detection_rules') \
                .select('*') \
                .neq('detection_config', {}) \
                .execute()
            
            if response.data:
                logger.info(f"Fetched {len(response.data)} detection rules from database")
                return response.data
            
            logger.warning("No detection rules found with detection_config")
            return []
            
        except Exception as e:
            logger.error(f"Failed to fetch detection rules: {e}")
            return []
    
    def fetch_cache_version(self) -> int:
        """
        Fetch current cache version from system_cache_control.
        
        Returns:
            Current cache version number
        """
        try:
            client = self._get_client()
            
            response = client.from_('system_cache_control') \
                .select('cache_version') \
                .eq('cache_key', 'cv_detection_rules') \
                .single() \
                .execute()
            
            if response.data:
                return response.data.get('cache_version', 1)
            return 1
            
        except Exception as e:
            logger.warning(f"Failed to fetch cache version: {e}")
            return 1
```

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE 2: backend/common/detection/rule_engine/cache.py
```python
"""
Rule Cache

In-memory cache for detection rules.
FOLLOWS: CatalogCache pattern from common/catalog/cache.py
Uses system_cache_control table for invalidation.
"""

import logging
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


@dataclass
class DetectionRule:
    """
    Represents a detection rule loaded from database.
    """
    issue_code: str
    display_name: str
    description: str
    detection_method: str
    detection_config: Dict[str, Any]
    severity: str
    weight: int
    can_auto_fix: bool
    auto_fix_type: Optional[str]
    static_tip: str
    user_effort: str
    example_before: Optional[str]
    example_after: Optional[str]
    category_code: str
    category_name: str
    subcategory_code: str
    subcategory_name: str
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DetectionRule':
        """Create DetectionRule from database row dictionary."""
        return cls(
            issue_code=data.get('issue_code', ''),
            display_name=data.get('display_name', ''),
            description=data.get('description', ''),
            detection_method=data.get('detection_method', ''),
            detection_config=data.get('detection_config') or {},
            severity=data.get('severity', 'consider'),
            weight=data.get('weight', 5),
            can_auto_fix=data.get('can_auto_fix', False),
            auto_fix_type=data.get('auto_fix_type'),
            static_tip=data.get('static_tip', ''),
            user_effort=data.get('user_effort', 'medium'),
            example_before=data.get('example_before'),
            example_after=data.get('example_after'),
            category_code=data.get('category_code', ''),
            category_name=data.get('category_name', ''),
            subcategory_code=data.get('subcategory_code', ''),
            subcategory_name=data.get('subcategory_name', ''),
        )


class RuleCache:
    """
    In-memory cache for detection rules.
    
    Invalidation:
    - Compares local cache_version with database cache_version
    - If different, reloads all rules
    - To invalidate: UPDATE system_cache_control SET cache_version = cache_version + 1
    """
    
    def __init__(self):
        self._rules: List[DetectionRule] = []
        self._rules_by_code: Dict[str, DetectionRule] = {}
        self._rules_by_category: Dict[str, List[DetectionRule]] = {}
        self._cache_version: int = 0
        self._is_loaded: bool = False
    
    @property
    def is_loaded(self) -> bool:
        return self._is_loaded
    
    @property
    def cache_version(self) -> int:
        return self._cache_version
    
    def load(self, rules_data: List[Dict[str, Any]], cache_version: int) -> None:
        """
        Load rules into cache.
        
        Args:
            rules_data: List of rule dictionaries from database
            cache_version: Current cache version from system_cache_control
        """
        self._rules = []
        self._rules_by_code = {}
        self._rules_by_category = {}
        
        for data in rules_data:
            rule = DetectionRule.from_dict(data)
            self._rules.append(rule)
            self._rules_by_code[rule.issue_code] = rule
            
            # Index by category
            if rule.category_code not in self._rules_by_category:
                self._rules_by_category[rule.category_code] = []
            self._rules_by_category[rule.category_code].append(rule)
        
        self._cache_version = cache_version
        self._is_loaded = True
        
        logger.info(f"Loaded {len(self._rules)} detection rules into cache (version {cache_version})")
    
    def get_all_rules(self) -> List[DetectionRule]:
        """Get all cached rules."""
        return self._rules.copy()
    
    def get_rule_by_code(self, issue_code: str) -> Optional[DetectionRule]:
        """Get a specific rule by issue code."""
        return self._rules_by_code.get(issue_code)
    
    def get_rules_by_category(self, category_code: str) -> List[DetectionRule]:
        """Get all rules for a category."""
        return self._rules_by_category.get(category_code, []).copy()
    
    def clear(self) -> None:
        """Clear the cache."""
        self._rules = []
        self._rules_by_code = {}
        self._rules_by_category = {}
        self._cache_version = 0
        self._is_loaded = False
```

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FILE 3: backend/common/detection/rule_engine/loader.py
```python
"""
Rule Loader

Loads detection rules from database with caching.
FOLLOWS: CatalogService singleton pattern from common/catalog/service.py

Usage:
    loader = get_rule_loader()
    rules = loader.get_all_rules()
"""

import logging
from typing import List, Optional

from .repository import RuleRepository
from .cache import RuleCache, DetectionRule

logger = logging.getLogger(__name__)


class RuleLoader:
    """
    Loads detection rules from database.
    
    Singleton pattern - use get_rule_loader() to get instance.
    
    Cache invalidation:
    - Automatically checks system_cache_control.cache_version
    - If version changed, reloads from database
    - Manual invalidation: call invalidate_cache()
    """
    
    _instance: Optional['RuleLoader'] = None
    
    def __init__(self, supabase_client=None):
        """
        Initialize RuleLoader.
        
        Args:
            supabase_client: Optional Supabase client for testing
        """
        self.repository = RuleRepository(supabase_client)
        self.cache = RuleCache()
        self._is_ready = False
    
    @classmethod
    def get_instance(cls, supabase_client=None) -> 'RuleLoader':
        """Get singleton instance."""
        if cls._instance is None:
            cls._instance = cls(supabase_client)
        return cls._instance
    
    @classmethod
    def reset_instance(cls) -> None:
        """Reset singleton (for testing)."""
        cls._instance = None
    
    @property
    def is_ready(self) -> bool:
        """Check if loader is ready (cache loaded)."""
        return self._is_ready and self.cache.is_loaded
    
    def initialize(self) -> bool:
        """
        Initialize the loader by loading rules from database.
        
        Returns:
            True if initialization successful
        """
        try:
            self._refresh_cache_if_needed()
            self._is_ready = True
            return True
        except Exception as e:
            logger.error(f"Failed to initialize RuleLoader: {e}")
            return False
    
    def get_all_rules(self) -> List[DetectionRule]:
        """
        Get all active detection rules.
        
        Automatically refreshes cache if version changed.
        
        Returns:
            List of DetectionRule objects
        """
        self._refresh_cache_if_needed()
        return self.cache.get_all_rules()
    
    def get_rule_by_code(self, issue_code: str) -> Optional[DetectionRule]:
        """Get a specific rule by issue code."""
        self._refresh_cache_if_needed()
        return self.cache.get_rule_by_code(issue_code)
    
    def get_rules_by_category(self, category_code: str) -> List[DetectionRule]:
        """Get all rules for a category."""
        self._refresh_cache_if_needed()
        return self.cache.get_rules_by_category(category_code)
    
    def invalidate_cache(self) -> None:
        """Force cache refresh on next access."""
        self.cache.clear()
        logger.info("Detection rules cache invalidated")
    
    def _refresh_cache_if_needed(self) -> None:
        """Refresh cache if version changed or not loaded."""
        db_version = self.repository.fetch_cache_version()
        
        if not self.cache.is_loaded or self.cache.cache_version != db_version:
            logger.info(f"Refreshing detection rules cache (db version: {db_version}, cache version: {self.cache.cache_version})")
            rules_data = self.repository.fetch_all_detection_rules()
            self.cache.load(rules_data, db_version)


# Module-level function for easy access (like get_catalog_service)
_loader_instance: Optional[RuleLoader] = None

def get_rule_loader() -> RuleLoader:
    """
    Get the RuleLoader singleton instance.
    
    Usage:
        from common.detection.rule_engine import get_rule_loader
        loader = get_rule_loader()
        rules = loader.get_all_rules()
    """
    global _loader_instance
    if _loader_instance is None:
        _loader_instance = RuleLoader.get_instance()
        _loader_instance.initialize()
    return _loader_instance
```

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

UPDATE: backend/common/detection/rule_engine/__init__.py
```python
"""
Rule Engine Module

Database-driven detection system for CV analysis.
"""

from .engine import RuleEngine
from .loader import RuleLoader, get_rule_loader
from .cache import DetectionRule

__all__ = ['RuleEngine', 'RuleLoader', 'DetectionRule', 'get_rule_loader']
```

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VERIFY: Check that import paths match your project structure.

Look at how CatalogService imports supabase_client and use the SAME path.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

WHEN COMPLETE:

Confirm:
â–¡ repository.py implemented
â–¡ cache.py implemented with DetectionRule dataclass
â–¡ loader.py implemented with singleton pattern
â–¡ __init__.py updated
â–¡ Import paths match existing code patterns
â–¡ No syntax errors

Type "REPLIT-2#23 COMPLETE" when done.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•