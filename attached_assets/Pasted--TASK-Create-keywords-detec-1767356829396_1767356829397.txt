═══════════════════════════════════════════════════════════════════════
TASK: Create keywords_detector.py + Decide on Grammar Detection
═══════════════════════════════════════════════════════════════════════

⚠️ CRITICAL RULES:
1. Create NEW file: backend/common/detection/keywords_detector.py
2. Follow SAME patterns as other detectors
3. Grammar detection is OPTIONAL - see decision section

═══════════════════════════════════════════════════════════════════════

PART A: CREATE keywords_detector.py

CREATE FILE: backend/common/detection/keywords_detector.py

───────────────────────────────────────────────────────────────────────
DETECTION 1: KEYWORDS_MISSING_INDUSTRY (weight: 7)
───────────────────────────────────────────────────────────────────────

def detect_missing_industry_keywords(cv_text: str, job_description: str = None) -> List[Dict[str, Any]]:
    """
    Detect if CV is missing keywords from job description.
    
    Note: This requires job_description parameter to be useful.
    If no job_description provided, skip this detection.
    """
    issues = []
    
    if not job_description:
        return issues  # Cannot detect without JD
    
    # Extract keywords from job description
    # Remove common words, keep nouns and technical terms
    common_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                   'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                   'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                   'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                   'we', 'you', 'your', 'our', 'their', 'this', 'that', 'these', 'those'}
    
    # Extract words from JD (3+ characters, not common)
    jd_words = set(re.findall(r'\b[a-zA-Z]{3,}\b', job_description.lower()))
    jd_keywords = jd_words - common_words
    
    # Extract words from CV
    cv_words = set(re.findall(r'\b[a-zA-Z]{3,}\b', cv_text.lower()))
    
    # Find missing keywords
    missing = jd_keywords - cv_words
    
    # Filter to important keywords (appear 2+ times in JD)
    jd_lower = job_description.lower()
    important_missing = [kw for kw in missing if jd_lower.count(kw) >= 2]
    
    if len(important_missing) > 5:
        issues.append({
            "issue_type": "KEYWORDS_MISSING_INDUSTRY",
            "location": "Throughout CV",
            "description": f"CV missing {len(important_missing)} keywords from job description",
            "current": ', '.join(important_missing[:10]),
            "suggestion": "Add relevant keywords from the job description naturally into your CV"
        })
    
    return issues

───────────────────────────────────────────────────────────────────────
DETECTION 2: KEYWORDS_SKILLS_FORMAT (weight: 5)
───────────────────────────────────────────────────────────────────────

def detect_skills_format(cv_text: str) -> List[Dict[str, Any]]:
    """
    Detect if skills are in paragraph format instead of organized list.
    """
    issues = []
    
    # Find skills section
    skills_match = re.search(
        r'\b(Skills|Technical\s+Skills|Core\s+Competencies)\s*:?\s*\n(.*?)(?=\n[A-Z]|\Z)',
        cv_text,
        re.IGNORECASE | re.DOTALL
    )
    
    if skills_match:
        skills_section = skills_match.group(2)
        
        # Check if it's a paragraph (long lines with commas) vs organized list
        lines = skills_section.strip().split('\n')
        
        # If single long line with many commas - it's paragraph format
        if len(lines) <= 2:
            comma_count = skills_section.count(',')
            if comma_count > 8:  # Many skills in comma-separated paragraph
                issues.append({
                    "issue_type": "KEYWORDS_SKILLS_FORMAT",
                    "location": "Skills section",
                    "description": "Skills listed in paragraph format are harder to scan",
                    "current": skills_section[:100] + "..." if len(skills_section) > 100 else skills_section,
                    "suggestion": "Organize skills into categories (Programming, Tools, Soft Skills, etc.)"
                })
    
    return issues

───────────────────────────────────────────────────────────────────────
DETECTION 3: KEYWORDS_ABBREVIATION_INCONSISTENT (weight: 3)
───────────────────────────────────────────────────────────────────────

def detect_abbreviation_inconsistency(cv_text: str) -> List[Dict[str, Any]]:
    """
    Detect inconsistent use of abbreviations vs full terms.
    """
    issues = []
    
    # Common abbreviation pairs
    abbreviation_pairs = [
        ('ML', 'Machine Learning'),
        ('AI', 'Artificial Intelligence'),
        ('NLP', 'Natural Language Processing'),
        ('API', 'Application Programming Interface'),
        ('UI', 'User Interface'),
        ('UX', 'User Experience'),
        ('SQL', 'Structured Query Language'),
        ('JS', 'JavaScript'),
        ('TS', 'TypeScript'),
        ('AWS', 'Amazon Web Services'),
        ('GCP', 'Google Cloud Platform'),
        ('CI/CD', 'Continuous Integration'),
        ('OOP', 'Object-Oriented Programming'),
        ('REST', 'Representational State Transfer'),
        ('HTML', 'HyperText Markup Language'),
        ('CSS', 'Cascading Style Sheets'),
    ]
    
    inconsistencies = []
    
    for abbrev, full in abbreviation_pairs:
        has_abbrev = re.search(r'\b' + abbrev + r'\b', cv_text)
        has_full = re.search(r'\b' + full + r'\b', cv_text, re.IGNORECASE)
        
        if has_abbrev and has_full:
            inconsistencies.append(f"Both '{abbrev}' and '{full}'")
    
    if inconsistencies:
        issues.append({
            "issue_type": "KEYWORDS_ABBREVIATION_INCONSISTENT",
            "location": "Throughout CV",
            "description": "Inconsistent abbreviation usage may confuse ATS",
            "current": ', '.join(inconsistencies[:3]),
            "suggestion": "Use consistent terminology - either abbreviation or full term, not both"
        })
    
    return issues

───────────────────────────────────────────────────────────────────────
MAIN FUNCTION
───────────────────────────────────────────────────────────────────────

def detect_keywords_issues(cv_text: str, job_description: str = None) -> List[Dict[str, Any]]:
    """
    Main function to detect all keyword-related issues.
    """
    issues = []
    
    issues.extend(detect_missing_industry_keywords(cv_text, job_description))
    issues.extend(detect_skills_format(cv_text))
    issues.extend(detect_abbreviation_inconsistency(cv_text))
    
    return issues

═══════════════════════════════════════════════════════════════════════

PART B: GRAMMAR DETECTION DECISION

The Gap Analysis shows GRAMMAR detection (7 issues) is currently DISABLED.

QUESTION FOR YOU:
Should we implement grammar detection?

OPTION 1: SKIP Grammar Detection
- Reason: Grammar/spelling detection is complex and error-prone
- Reason: May flag valid technical terms as misspellings
- Reason: Users can use external tools (Grammarly, Word)
- Action: Leave spelling_detector.py commented out

OPTION 2: IMPLEMENT Basic Grammar Detection
- Implement only simple, high-confidence patterns
- Focus on: article misuse, inconsistent periods
- Skip: complex spelling, tense detection
- Risk: May still have false positives

RECOMMENDED: OPTION 1 (Skip)
Grammar detection adds complexity with high risk of false positives.
Better to focus on content/structure issues we can detect reliably.

⚠️ STOP and confirm which option before implementing.

If OPTION 2 chosen, implement these only:
- GRAMMAR_ARTICLE_MISUSE: "a engineer" → "an engineer"
- GRAMMAR_INCONSISTENT_PERIODS: Some bullets end with period, some don't

═══════════════════════════════════════════════════════════════════════

DELIVERABLES:
1. Create backend/common/detection/keywords_detector.py
2. Include 3 detection functions
3. WAIT for grammar decision before proceeding

═══════════════════════════════════════════════════════════════════════