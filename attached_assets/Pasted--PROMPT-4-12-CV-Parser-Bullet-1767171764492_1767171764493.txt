═══════════════════════════════════════════════════════════════════
PROMPT 4#12: CV Parser - Bullet Extractor
═══════════════════════════════════════════════════════════════════

⚠️ CRITICAL COMPLIANCE ⚠️
- Execute ONLY instructions below
- Bullet extraction uses patterns - no AI
- Same text → Same bullets extracted

───────────────────────────────────────────────────────────────────

TASK: Create bullet point extractor

OBJECTIVE:
Extract individual bullet points (achievements/responsibilities)
from CV text using pattern matching. 100% deterministic.

───────────────────────────────────────────────────────────────────

INSTRUCTIONS:

Step 1: CREATE file: backend/common/detection/bullet_extractor.py

Step 2: Add this content:

"""
CV Bullet Point Extractor

Extracts and analyzes individual bullet points/achievements.
100% CODE - No AI - Deterministic results.
"""

import re
from typing import List, Dict, Optional
from dataclasses import dataclass


@dataclass
class BulletPoint:
    """A single bullet point from CV."""
    text: str
    line_number: int
    word_count: int
    has_metrics: bool
    has_strong_verb: bool
    starts_with_verb: bool
    metrics_found: List[str]


# ═══════════════════════════════════════════════════════════════════
# PATTERNS
# ═══════════════════════════════════════════════════════════════════

# Bullet markers
BULLET_MARKERS = re.compile(r'^[\s]*[•\-\*\>\◦\▪\●\○][\s]+', re.MULTILINE)

# Metrics patterns (numbers, percentages, currency)
METRICS_PATTERNS = [
    re.compile(r'\d+%'),                          # Percentages: 50%
    re.compile(r'\$[\d,]+(?:\.\d{2})?[KMB]?'),    # Currency: $1,000 or $1M
    re.compile(r'[\d,]+\+?(?:\s+)(?:users?|customers?|clients?|employees?|people|members?|subscribers?|visitors?)', re.IGNORECASE),
    re.compile(r'(?:increased?|decreased?|reduced?|improved?|grew?|raised?|cut|saved?)\s+(?:by\s+)?\d+', re.IGNORECASE),
    re.compile(r'\d+x\b'),                         # Multipliers: 2x, 10x
    re.compile(r'#\d+\b'),                         # Rankings: #1, #2
    re.compile(r'\b\d{1,3}(?:,\d{3})+\b'),        # Large numbers: 1,000,000
]

# Strong action verbs (starts of bullets)
STRONG_VERB_STARTS = [
    'achieved', 'accomplished', 'accelerated', 'acquired', 'advanced',
    'built', 'boosted',
    'created', 'championed', 'consolidated', 'coordinated',
    'delivered', 'designed', 'developed', 'directed', 'drove',
    'earned', 'eliminated', 'enhanced', 'established', 'exceeded', 'expanded',
    'facilitated', 'founded',
    'generated', 'grew', 'guided',
    'headed',
    'identified', 'implemented', 'improved', 'increased', 'initiated', 'introduced',
    'launched', 'led',
    'managed', 'maximized', 'mentored', 'modernized',
    'negotiated',
    'optimized', 'orchestrated', 'organized', 'oversaw',
    'partnered', 'pioneered', 'planned', 'presented', 'produced', 'programmed',
    'raised', 'reduced', 'redesigned', 'reorganized', 'resolved', 'restructured', 'revamped',
    'saved', 'scaled', 'secured', 'simplified', 'spearheaded', 'standardized', 'streamlined', 'strengthened', 'supervised',
    'trained', 'transformed',
    'unified', 'upgraded',
    'won',
]


def extract_bullets(text: str) -> List[BulletPoint]:
    """
    Extract all bullet points from text.
    
    Args:
        text: CV text (or section text)
        
    Returns:
        List of BulletPoint objects
    """
    bullets = []
    lines = text.split('\n')
    
    for i, line in enumerate(lines):
        line = line.strip()
        
        # Check if line is a bullet
        is_bullet = False
        clean_line = line
        
        # Check for bullet markers
        if BULLET_MARKERS.match(line):
            is_bullet = True
            clean_line = BULLET_MARKERS.sub('', line).strip()
        # Check for lines that start with action verbs (implicit bullets)
        elif line and line[0].isupper():
            first_word = line.split()[0].lower().rstrip('ed').rstrip('ing') if line.split() else ''
            # Check various verb forms
            for verb in STRONG_VERB_STARTS:
                if first_word == verb or first_word == verb.rstrip('ed') or line.lower().startswith(verb):
                    is_bullet = True
                    clean_line = line
                    break
        
        if is_bullet and len(clean_line) > 10:  # Minimum length for a real bullet
            bullet = analyze_bullet(clean_line, i + 1)
            bullets.append(bullet)
    
    return bullets


def analyze_bullet(text: str, line_number: int) -> BulletPoint:
    """
    Analyze a single bullet point.
    
    Args:
        text: The bullet text
        line_number: Line number in original document
        
    Returns:
        BulletPoint with analysis
    """
    # Find metrics
    metrics_found = []
    for pattern in METRICS_PATTERNS:
        matches = pattern.findall(text)
        metrics_found.extend(matches)
    
    # Check first word
    words = text.split()
    first_word = words[0].lower().rstrip(',.:;') if words else ''
    
    # Check if starts with strong verb
    starts_with_verb = any(
        first_word == verb or first_word.startswith(verb.rstrip('ed'))
        for verb in STRONG_VERB_STARTS
    )
    
    # Check if has any strong verb
    text_lower = text.lower()
    has_strong_verb = any(verb in text_lower for verb in STRONG_VERB_STARTS)
    
    return BulletPoint(
        text=text,
        line_number=line_number,
        word_count=len(words),
        has_metrics=len(metrics_found) > 0,
        has_strong_verb=has_strong_verb,
        starts_with_verb=starts_with_verb,
        metrics_found=metrics_found,
    )


def get_bullet_issues(bullets: List[BulletPoint]) -> List[Dict]:
    """
    Generate issues based on bullet analysis.
    
    Args:
        bullets: List of extracted BulletPoint objects
        
    Returns:
        List of issue dictionaries with issue_type
    """
    issues = []
    
    for bullet in bullets:
        # No metrics in bullet
        if not bullet.has_metrics:
            issues.append({
                'issue_type': 'NO_METRICS',
                'location': f'Line {bullet.line_number}',
                'description': 'Bullet point lacks quantified achievement (no numbers, percentages, or metrics)',
                'current': bullet.text[:100] + '...' if len(bullet.text) > 100 else bullet.text,
            })
        
        # Doesn't start with action verb
        if not bullet.starts_with_verb:
            issues.append({
                'issue_type': 'BULLET_FORMAT',
                'location': f'Line {bullet.line_number}',
                'description': 'Bullet should start with a strong action verb',
                'current': bullet.text[:50] + '...' if len(bullet.text) > 50 else bullet.text,
            })
        
        # Bullet too long
        if bullet.word_count > 30:
            issues.append({
                'issue_type': 'BULLET_TOO_LONG',
                'location': f'Line {bullet.line_number}',
                'description': f'Bullet is {bullet.word_count} words - consider splitting or condensing',
                'current': bullet.text[:100] + '...',
            })
        
        # Bullet too short
        if bullet.word_count < 5:
            issues.append({
                'issue_type': 'BULLET_TOO_SHORT',
                'location': f'Line {bullet.line_number}',
                'description': f'Bullet is only {bullet.word_count} words - add more detail',
                'current': bullet.text,
            })
    
    return issues

───────────────────────────────────────────────────────────────────

FILES TO CREATE:
- backend/common/detection/bullet_extractor.py

DO NOT TOUCH:
- All other files

───────────────────────────────────────────────────────────────────

WHEN COMPLETE:

Confirm:
□ bullet_extractor.py created
□ METRICS_PATTERNS defined (percentages, currency, etc.)
□ STRONG_VERB_STARTS list defined
□ extract_bullets function works
□ get_bullet_issues returns NO_METRICS, BULLET_TOO_LONG, etc.
□ No Python syntax errors

Type "PROMPT 4#12 COMPLETE - READY FOR 5#12" when done.